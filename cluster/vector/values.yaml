# Vector Configuration - Log collector DaemonSet
# Collects logs from Kubernetes and external devices (syslog, HTTP)

# Role for Vector
role: Agent

# Custom configuration for Vector
customConfig:
  data_dir: /vector-data-dir
  
  api:
    enabled: true
    address: 127.0.0.1:8686
    playground: false
  
  # Sources: Collect logs from multiple sources
  sources:
    # Kubernetes pod logs
    kubernetes_logs:
      type: kubernetes_logs
      max_read_bytes: 16384
      glob_minimum_cooldown_ms: 15000
      auto_partial_merge: true
      self_node_name: ${VECTOR_SELF_NODE_NAME}
    
    # Syslog UDP for network devices (UDM, switches, etc)
    syslog_udp:
      type: syslog
      address: 0.0.0.0:514
      mode: udp
    
    # Syslog TCP (optional, more reliable)
    syslog_tcp:
      type: syslog
      address: 0.0.0.0:1514
      mode: tcp
    
    # HTTP endpoint for applications that can send JSON
    http_logs:
      type: http_server
      address: 0.0.0.0:8080
      encoding: json
      
  # Transforms: Parse and enrich logs
  transforms:
    # Parse Kubernetes logs
    kubernetes_parsed:
      type: remap
      inputs:
        - kubernetes_logs
      source: |
        .cluster = "kng"
        
        # Parse Kubernetes metadata
        if exists(.kubernetes) {
          .node = del(.kubernetes.pod_node_name)
          .namespace = del(.kubernetes.pod_namespace)
          .pod = del(.kubernetes.pod_name)
          .container = del(.kubernetes.container_name)
          del(.kubernetes)
          .job = "logging"
        }
        
        # Detect log level
        level = parse_regex(.message, r'level=(?P<level>\w+)') ?? {}
        if level.level != null {
          .detected_level = downcase!(level.level)
        } else {
          .detected_level = "unknown"
        }
        
        # Extract service name from container
        if exists(.container) {
          .service_name = .container
        }
    
    # Parse syslog messages from network devices
    syslog_parsed:
      type: remap
      inputs:
        - syslog_udp
        - syslog_tcp
      source: |
        .cluster = "kng"
        
        # Extract hostname as job (hostname is always present in syslog)
        .job = .hostname
        
        # Detect device type from hostname
        hostname = .hostname
        if starts_with(hostname, "udm") || starts_with(hostname, "UDM") {
          .device_type = "udm"
        } else if starts_with(hostname, "USW") || starts_with(hostname, "usw") {
          .device_type = "unifi_switch"
        } else if starts_with(hostname, "UAP") || starts_with(hostname, "uap") {
          .device_type = "unifi_ap"
        } else {
          .device_type = "network_device"
        }
        
        # Extract severity as level (use to_string to handle severity)
        .detected_level = to_string(.severity) ?? "unknown"
    
    # Parse HTTP logs from external applications
    http_logs_parsed:
      type: remap
      inputs:
        - http_logs
      source: |
        .cluster = "kng"
        
        # Extract device info from payload (handle missing fields)
        if exists(.device) {
          .job = .device
        } else if exists(.hostname) {
          .job = .hostname
        } else {
          .job = "external"
        }
        
        if exists(.device) {
          .device_type = .device
        } else {
          .device_type = "app"
        }
        
        # Preserve or detect log level
        if exists(.level) {
          .detected_level = downcase(.level) ?? "unknown"
        } else if exists(.severity) {
          .detected_level = downcase(.severity) ?? "unknown"
        } else {
          .detected_level = "unknown"
        }
        
        # Ensure message field exists
        if !exists(.message) && exists(.msg) {
          .message = del(.msg)
        }
  
  # Sinks: Send all logs to Loki
  sinks:
    loki:
      type: loki
      inputs:
        - kubernetes_parsed
        - syslog_parsed
        - http_logs_parsed
      endpoint: http://loki-gateway.logging.svc.cluster.local
      encoding:
        codec: json
      labels:
        cluster: "{{`{{ cluster }}`}}"
        job: "{{`{{ job }}`}}"
        namespace: "{{`{{ namespace }}`}}"
        pod: "{{`{{ pod }}`}}"
        container: "{{`{{ container }}`}}"
        node: "{{`{{ node }}`}}"
        service_name: "{{`{{ service_name }}`}}"
        detected_level: "{{`{{ detected_level }}`}}"
        device_type: "{{`{{ device_type }}`}}"
      # Buffer configuration for reliability
      buffer:
        type: disk
        max_size: 268435488  # 256 MiB
      request:
        retry_attempts: 5
        retry_initial_backoff_secs: 1
        retry_max_duration_secs: 10

# Pod configuration
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8686"

# Note: VECTOR_SELF_NODE_NAME, VECTOR_SELF_POD_NAME, and VECTOR_SELF_POD_NAMESPACE 
# are automatically added by the Vector Helm chart when role=Agent

# Resources
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi

# Tolerations to run on all nodes including control plane
tolerations:
  - effect: NoSchedule
    operator: Exists

# Service for syslog and HTTP log ingestion
service:
  enabled: true
  type: LoadBalancer
  annotations:
    io.cilium/lb-ipam-ips: "10.0.2.70"
  ports:
    - name: syslog-udp
      protocol: UDP
      port: 514
      targetPort: 514
    - name: syslog-tcp
      protocol: TCP
      port: 1514
      targetPort: 1514
    - name: http-logs
      protocol: TCP
      port: 8080
      targetPort: 8080
    - name: metrics
      port: 8686
      protocol: TCP
      targetPort: 8686

# ServiceMonitor for Prometheus
serviceMonitor:
  enabled: true
  additionalLabels:
    release: kube-prometheus-stack

# Persistence for buffer
persistence:
  enabled: true
  storageClassName: longhorn
  size: 10Gi
  accessModes:
    - ReadWriteOnce

# Update strategy
updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1

# Ingress for HTTP log collection
ingress:
  enabled: true
  className: cilium
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-dns
  hosts:
    - host: logs.kng.house
      paths:
        - path: /
          pathType: Prefix
          port:
            name: http-logs
            number: 8080
  tls:
    - secretName: vector-logs-tls
      hosts:
        - logs.kng.house
