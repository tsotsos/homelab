# Vector Configuration - Log collector DaemonSet
# Collects logs from Kubernetes and external devices (syslog, HTTP)

# Role for Vector
role: Agent

# Custom configuration for Vector
customConfig:
  data_dir: /vector-data-dir
  
  api:
    enabled: true
    address: 127.0.0.1:8686
    playground: false
  
  # Sources: Collect logs from multiple sources
  sources:
    # Kubernetes pod logs
    kubernetes_logs:
      type: kubernetes_logs
      max_read_bytes: 16384
      glob_minimum_cooldown_ms: 15000
      auto_partial_merge: true
      self_node_name: ${VECTOR_SELF_NODE_NAME}
    
    # Syslog UDP for network devices (UDM, switches, etc)
    # Using socket type to accept any format, parse manually in transform
    syslog_udp:
      type: socket
      address: 0.0.0.0:514
      mode: udp
      max_length: 102400
      decoding:
        codec: bytes
    
    # Syslog TCP (optional, more reliable)
    syslog_tcp:
      type: socket
      address: 0.0.0.0:1514
      mode: tcp
      max_length: 102400
      decoding:
        codec: bytes
    
    # HTTP endpoint for applications that can send JSON
    http_logs:
      type: http_server
      address: 0.0.0.0:8080
      encoding: json
      
  # Transforms: Parse and enrich logs
  transforms:
    # Parse Kubernetes logs
    kubernetes_parsed:
      type: remap
      inputs:
        - kubernetes_logs
      source: |
        .cluster = "kng"
        .device_type = "kubernetes"
        
        # Parse Kubernetes metadata
        if exists(.kubernetes) {
          .node = del(.kubernetes.pod_node_name)
          .namespace = del(.kubernetes.pod_namespace)
          .pod = del(.kubernetes.pod_name)
          .container = del(.kubernetes.container_name)
          del(.kubernetes)
          .job = "logging"
        }
        
        # Detect log level
        level = parse_regex(.message, r'level=(?P<level>\w+)') ?? {}
        if level.level != null {
          .detected_level = downcase!(level.level)
        } else {
          .detected_level = "unknown"
        }
        
        # Extract service name from container
        if exists(.container) {
          .service_name = .container
        }
    
    # Parse syslog messages from network devices
    syslog_parsed:
      type: remap
      inputs:
        - syslog_udp
        - syslog_tcp
      source: |
        .cluster = "kng"
        
        # Convert bytes to string for parsing
        message_text = to_string!(.message)
        
        # Initialize hostname variable
        hostname = "unknown"
        
        # Try to parse syslog with priority: <PRI>TIMESTAMP HOSTNAME MESSAGE
        # Example: <78>Nov 29 04:00:00 AtticAP message here
        # Regex explanation: <digits>Month Day HH:MM:SS Hostname Rest
        syslog_parts = parse_regex(message_text, r'^<\d+>([A-Za-z]{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+([^\s]+)\s+(.*)$') ?? {}
        
        # Extract captured groups
        if length(syslog_parts) >= 3 {
          .timestamp = syslog_parts[0]
          .hostname = syslog_parts[1]
          .message = syslog_parts[2]
          hostname = syslog_parts[1]
        } else {
          # Fallback: try without priority
          syslog_parts = parse_regex(message_text, r'^([A-Za-z]{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+([^\s]+)\s+(.*)$') ?? {}
          if length(syslog_parts) >= 3 {
            .timestamp = syslog_parts[0]
            .hostname = syslog_parts[1]
            .message = syslog_parts[2]
            hostname = syslog_parts[1]
          } else {
            # Last resort: use first word as hostname
            parts = split(message_text, " ", limit: 2)
            if length(parts) >= 2 {
              hostname = parts[0]
              .message = parts[1]
            } else {
              hostname = "unknown"
              .message = message_text
            }
          }
        }
        
        # Extract priority if present
        pri_match = parse_regex(message_text, r'^<(?P<pri>\d+)>') ?? {}
        if pri_match.pri != null {
          pri = to_int!(pri_match.pri)
          severity = mod(pri, 8)
          .detected_level = if severity == 0 {
            "emergency"
          } else if severity == 1 {
            "alert"
          } else if severity == 2 {
            "critical"
          } else if severity == 3 {
            "error"
          } else if severity == 4 {
            "warning"
          } else if severity == 5 {
            "notice"
          } else if severity == 6 {
            "info"
          } else {
            "debug"
          }
        } else {
          .detected_level = "info"
        }
        
        # Ensure hostname is always a string (never null)
        hostname = to_string(hostname) ?? "unknown"
        .job = hostname
        .hostname = hostname
        
        # Detect device type from hostname
        if starts_with(hostname, "udm") || starts_with(hostname, "UDM") {
          .device_type = "udm"
        } else if starts_with(hostname, "Switch") || starts_with(hostname, "USW") || starts_with(hostname, "usw") {
          .device_type = "unifi_switch"
        } else if starts_with(hostname, "UAP") || starts_with(hostname, "uap") || contains(hostname, "AP") {
          .device_type = "unifi_ap"
        } else {
          .device_type = "network_device"
        }
        
        # Set empty values for Kubernetes-specific fields to prevent Loki errors
        .namespace = "none"
        .pod = "none"
        .container = "none"
        .node = "none"
        .service_name = "syslog"
    
    # Parse HTTP logs from external applications
    http_logs_parsed:
      type: remap
      inputs:
        - http_logs
      source: |
        .cluster = "kng"
        
        # Extract device info from payload (handle missing fields)
        if exists(.device) {
          .job = .device
        } else if exists(.hostname) {
          .job = .hostname
        } else {
          .job = "external"
        }
        
        if exists(.device) {
          .device_type = .device
        } else {
          .device_type = "app"
        }
        
        # Preserve or detect log level
        if exists(.level) {
          .detected_level = downcase(.level) ?? "unknown"
        } else if exists(.severity) {
          .detected_level = downcase(.severity) ?? "unknown"
        } else {
          .detected_level = "unknown"
        }
        
        # Ensure message field exists
        if !exists(.message) && exists(.msg) {
          .message = del(.msg)
        }
        
        # Set empty values for Kubernetes-specific fields to prevent Loki errors
        .namespace = "none"
        .pod = "none"
        .container = "none"
        .node = "none"
        .service_name = "http"
  
  # Sinks: Send all logs to Loki
  sinks:
    loki:
      type: loki
      inputs:
        - kubernetes_parsed
        - syslog_parsed
        - http_logs_parsed
      endpoint: http://loki-gateway.logging.svc.cluster.local
      encoding:
        codec: json
      labels:
        cluster: "{{`{{ cluster }}`}}"
        job: "{{`{{ job }}`}}"
        namespace: "{{`{{ namespace }}`}}"
        pod: "{{`{{ pod }}`}}"
        container: "{{`{{ container }}`}}"
        node: "{{`{{ node }}`}}"
        service_name: "{{`{{ service_name }}`}}"
        detected_level: "{{`{{ detected_level }}`}}"
        device_type: "{{`{{ device_type }}`}}"
      # Buffer configuration for reliability
      buffer:
        type: disk
        max_size: 268435488  # 256 MiB
      request:
        retry_attempts: 5
        retry_initial_backoff_secs: 1
        retry_max_duration_secs: 10

# Pod configuration
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8686"

# Note: VECTOR_SELF_NODE_NAME, VECTOR_SELF_POD_NAME, and VECTOR_SELF_POD_NAMESPACE 
# are automatically added by the Vector Helm chart when role=Agent

# Resources
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi

# Tolerations to run on all nodes including control plane
tolerations:
  - effect: NoSchedule
    operator: Exists

# Service for syslog and HTTP log ingestion
service:
  enabled: true
  type: LoadBalancer
  # IP will be automatically assigned from kube-vip range (10.0.2.75-10.0.2.99)
  ports:
    - name: syslog-udp
      protocol: UDP
      port: 514
      targetPort: 514
    - name: syslog-tcp
      protocol: TCP
      port: 1514
      targetPort: 1514
    - name: http-logs
      protocol: TCP
      port: 8080
      targetPort: 8080
    - name: metrics
      port: 8686
      protocol: TCP
      targetPort: 8686

# PodMonitor for Prometheus
podMonitor:
  enabled: true
  additionalLabels:
    release: kube-prometheus-stack

# Persistence for buffer
persistence:
  enabled: true
  storageClassName: longhorn
  size: 10Gi
  accessModes:
    - ReadWriteOnce

# Update strategy
updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1

# Ingress for HTTP log collection
ingress:
  enabled: true
  className: cilium
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-dns
  hosts:
    - host: logs.kng.house
      paths:
        - path: /
          pathType: Prefix
          port:
            name: http-logs
            number: 8080
  tls:
    - secretName: vector-logs-tls
      hosts:
        - logs.kng.house
